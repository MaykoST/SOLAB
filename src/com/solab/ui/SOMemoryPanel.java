/*
 * SOMemoryPanel.java
 *
 * Created on 7 de Maio de 2008, 19:37
 */
package com.solab.ui;

import com.solab.model.event.SOMemoryEvent;
import com.solab.model.event.SOMemoryListener;
import com.solab.so.SO;
import com.solab.so.SOPageTableIndex;
import com.solab.so.SOProcess;
import com.solab.util.SOConstants;
import java.awt.Color;
import java.awt.Graphics;

/**
 * $Id: SOMemoryPanel.java,v 1.2 2008/05/14 00:11:35 Mayko Exp $
 *
 * @author Mayko Sartor - <a
 *         href="mailto:maykosartor@gmail.com">maykosartor@gmail.com </a><br>
 */
public class SOMemoryPanel extends javax.swing.JPanel implements SOMemoryListener {

    private SO so;
    private static final int SQUARE_SIZE = 40;
    private static final int SQUARE_HEIGHT = 35;

    /** Creates new form SOMemoryPanel */
    public SOMemoryPanel() {
        initComponents();
        this.setBackground(Color.WHITE);
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);

        //Desenha a grade
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                g.drawRect((j * SQUARE_SIZE) + 2, (i * SQUARE_HEIGHT) + 2, SQUARE_SIZE, SQUARE_HEIGHT);
            }
        }

        //Desenha as paginas de memória
        this.drawMemory(g);
    }

    public void drawMemory(Graphics g) {
        if (this.so == null) {
            return;
        }

        if (this.so.getSoMemory() == null) {
            return;
        }

        if (this.so.getSoMemory().getPageTable() == null) {
            return;
        }

        int x;
        int y;
        int addr;
        int pag;

        /*
        for(SOPageTableIndex pIndex : this.so.getSoMemory().getPageTable()) {
        if ((pIndex.getPhysicalAddress() != -1) && (!pIndex.isFree())) {
        //O endereço do frame é sempre multiplo do tamanho da pagina
        //desta forma é necessario dividir para chegar a sequencia numerica
        addr = pIndex.getPhysicalAddress() / SOConstants.PAGE_SIZE;  
        y = (int) addr / 10;
        x = addr % 10;
        
        g.setColor(Color.GREEN);
        g.fillRect((x  * SQUARE_SIZE) + 3, (y  * SQUARE_SIZE) + 3, SQUARE_SIZE - 1,  SQUARE_SIZE - 1);                
        }
        }
         */

        //Fazer pela lista de processos
        synchronized (this.so.getProcessQueue()) {
            for (SOProcess soProc : this.so.getProcessQueue()) {
                pag = 1;
                for (SOPageTableIndex pIndex : soProc.getPageTable()) {
                    //O endereço do frame é sempre multiplo do tamanho da pagina
                    //desta forma é necessario dividir para chegar a sequencia numerica
                    addr = pIndex.getPhysicalAddress() / SOConstants.PAGE_SIZE;
                    y = (int) addr / 10;
                    x = addr % 10;

                    g.setColor(soProc.getColor());
                    g.fillRect((x * SQUARE_SIZE) + 3, (y * SQUARE_HEIGHT) + 3, SQUARE_SIZE - 1, SQUARE_HEIGHT - 1);

                    g.setColor(Color.BLACK);
                    g.drawString(soProc.getName(), (x * SQUARE_SIZE) + 6, (y * SQUARE_HEIGHT) + 15);
                    g.drawString("Pg-> " + pag, (x * SQUARE_SIZE) + 6, (y * SQUARE_HEIGHT) + 30);

                    pag++;
                }
            }
        }

        //Fazer pela lista de processos
        //Repete para a lista de processos bloqueados
        synchronized (this.so.getLockQueue()) {
            for (SOProcess soProc : this.so.getLockQueue()) {
                pag = 1;
                for (SOPageTableIndex pIndex : soProc.getPageTable()) {
                    //O endereço do frame é sempre multiplo do tamanho da pagina
                    //desta forma é necessario dividir para chegar a sequencia numerica
                    addr = pIndex.getPhysicalAddress() / SOConstants.PAGE_SIZE;
                    y = (int) addr / 10;
                    x = addr % 10;

                    g.setColor(soProc.getColor());
                    g.fillRect((x * SQUARE_SIZE) + 3, (y * SQUARE_HEIGHT) + 3, SQUARE_SIZE - 1, SQUARE_HEIGHT - 1);

                    g.setColor(Color.BLACK);
                    g.drawString(soProc.getName(), (x * SQUARE_SIZE) + 6, (y * SQUARE_HEIGHT) + 15);
                    g.drawString("Pg -> " + pag, (x * SQUARE_SIZE) + 6, (y * SQUARE_HEIGHT) + 30);
                }
            }
        }
    }

    public SO getSo() {
        return so;
    }

    public void setSo(SO so) {
        this.so = so;
    }

    public void memoryChanged(SOMemoryEvent e) {
        this.repaint();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 627, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 504, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
